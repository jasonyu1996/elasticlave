//******************************************************************************
// Copyright (c) 2018, The Regents of the University of California (Regents).
// All Rights Reserved. See LICENSE for license details.
//------------------------------------------------------------------------------
#include "edge_wrapper.h"
#include "edge_call.h"
#include "edge_dispatch.h"
#include "report.h"
#include "keystone.h"
#include <string.h>
/* Really all of this file should be autogenerated, that will happen
   eventually. */

#define OCALL_GET_RECORD_SIZE 4
#define OCALL_GET_OTHER_ENCLAVE 5
#define ENCLAVE_MAX_COUNT 8

Keystone* enclaves[ENCLAVE_MAX_COUNT]; 
int enclave_n;
size_t record_size;

int edge_init(Keystone* enclave, DefaultEdgeCallDispatcher* dispatcher){
  enclave->registerOcallDispatch(dispatcher);
  dispatcher->register_call(OCALL_GET_RECORD_SIZE, get_record_size_wrapper, NULL);
  dispatcher->register_call(OCALL_GET_OTHER_ENCLAVE, get_other_enclave_wrapper, NULL);
  return 0;
}

int get_record_size_wrapper(Keystone* encalve, void* buffer, struct shared_region* shared_region){
    struct edge_call* edge_call = (struct edge_call*)buffer;
	uintptr_t data_section = edge_call_data_ptr(shared_region);
	*(size_t*)data_section = record_size;
	if(edge_call_setup_ret(edge_call,
				(void*)data_section, sizeof(record_size), shared_region)){
		edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
	} else{
		edge_call->return_data.call_status = CALL_STATUS_OK;
	}
	return 0;
}

int get_other_enclave_wrapper(Keystone* enclave, void* buffer, struct shared_region* shared_region){
    struct edge_call* edge_call = (struct edge_call*)buffer;
	int i;
	for(i = 0; i < enclave_n; i ++){
		if(enclaves[i] != enclave){
			break;
		}
	}
	if(i >= enclave_n){
		edge_call->return_data.call_status = CALL_STATUS_ERROR;
	} else{
		uintptr_t data_section = edge_call_data_ptr(shared_region);
		int sid = enclaves[i]->getSID();
		memcpy((void*)data_section, &sid, sizeof(sid));
		if(edge_call_setup_ret(edge_call,
				   	(void*)data_section, sizeof(sid), shared_region)){
			edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
		} else{
			edge_call->return_data.call_status = CALL_STATUS_OK;
		}
	}
return 0;
}

