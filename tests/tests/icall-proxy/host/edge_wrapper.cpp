//******************************************************************************
// Copyright (c) 2018, The Regents of the University of California (Regents).
// All Rights Reserved. See LICENSE for license details.
//------------------------------------------------------------------------------
#include "edge_wrapper.h"
#include "edge_call.h"
#include "edge_dispatch.h"
#include "report.h"
#include "keystone.h"
#include <string.h>
/* Really all of this file should be autogenerated, that will happen
   eventually. */

#define OCALL_GET_RECORD_SIZE 4
#define OCALL_GET_OTHER_ENCLAVE 5
#define ENCLAVE_MAX_COUNT 8

Keystone* enclaves[ENCLAVE_MAX_COUNT]; 
int enclave_n;
size_t record_size;

int edge_init(Keystone* enclave, DefaultEdgeCallDispatcher* dispatcher){
    enclave->registerOcallDispatch(dispatcher);
    dispatcher->register_call(OCALL_GET_RECORD_SIZE, get_record_size_wrapper, NULL);
    dispatcher->register_call(OCALL_GET_OTHER_ENCLAVE, get_other_enclave_wrapper, NULL);
    return 0;
}

int get_record_size_wrapper(Keystone* encalve, void* buffer, struct shared_region* shared_region){
    struct edge_call* edge_call = (struct edge_call*)buffer;
    uintptr_t data_section = edge_call_data_ptr(shared_region);
    *(size_t*)data_section = record_size;
    if(edge_call_setup_ret(edge_call,
                (void*)data_section, sizeof(record_size), shared_region)){
        edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    } else{
        edge_call->return_data.call_status = CALL_STATUS_OK;
    }
    return 0;
}

int get_other_enclave_wrapper(Keystone* enclave, void* buffer, struct shared_region* shared_region){
    struct edge_call* edge_call = (struct edge_call*)buffer;
    int i;
    for(i = 0; i < enclave_n; i ++){
        if(enclaves[i] != enclave){
            break;
        }
    }
    if(i >= enclave_n){
        edge_call->return_data.call_status = CALL_STATUS_ERROR;
    } else{
        uintptr_t data_section = edge_call_data_ptr(shared_region);
        int sid = enclaves[i]->getSID();
        memcpy((void*)data_section, &sid, sizeof(sid));
        if(edge_call_setup_ret(edge_call,
                    (void*)data_section, sizeof(sid), shared_region)){
            edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
        } else{
            edge_call->return_data.call_status = CALL_STATUS_OK;
        }
    }
    return 0;
}

